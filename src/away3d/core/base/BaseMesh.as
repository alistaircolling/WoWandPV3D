package away3d.core.base{    import away3d.core.*;    import away3d.core.draw.*;    import away3d.core.render.*;    import away3d.core.utils.*;    import away3d.events.*;    import away3d.materials.*;        import flash.events.Event;    import flash.utils.*;    	 /**	 * Dispatched when the animation object completes all frame sequences.	 * 	 * @eventType away3d.events.AnimationEvent	 */	[Event(name="sequencedone",type="away3d.events.AnimationEvent")]		 /**	 * Dispatched when the animation object completes a single sequence cycle.	 * 	 * @eventType away3d.events.AnimationEvent	 */	[Event(name="cycle",type="away3d.events.AnimationEvent")]	    /**    * Abstract 3d object containing unspecified elements.    * Not intended for direct use - use <code>Mesh</code> or <code>WireMesh</code>.    */    public class BaseMesh extends Object3D    {        use namespace arcane;		/** @private */        arcane function createDrawSegment(material:ISegmentMaterial, projection:Projection, v0:ScreenVertex, v1:ScreenVertex):DrawSegment        {            if (_dsStore.length) {            	_dsActive.push(_seg = _dsStore.pop());            	_seg.create = createDrawSegment;        	} else {            	_dsActive.push(_seg = new DrawSegment());	            _seg.source = this;	            _seg.create = createDrawSegment;            }            _seg.material = material;            _seg.projection = projection;            _seg.v0 = v0;            _seg.v1 = v1;            _seg.calc();            return _seg;        }                private var _vertices:Array;        private var _verticesDirty:Boolean = true;        private var _boundingRadiusElement:IMeshElement = null;        private var _boundingRadiusDirty:Boolean = false;        private var _boundingRadius:Number = 0;		private var _maxXElement:IMeshElement = null;        private var _maxXDirty:Boolean = false;        private var _maxX:Number = -Infinity;        private var _minXElement:IMeshElement = null;        private var _minXDirty:Boolean = false;        private var _minX:Number = Infinity;        private var _maxYElement:IMeshElement = null;        private var _maxYDirty:Boolean = false;        private var _maxY:Number = -Infinity;		private var _minYElement:IMeshElement = null;        private var _minYDirty:Boolean = false;        private var _minY:Number = Infinity;        private var _maxZElement:IMeshElement = null;        private var _maxZDirty:Boolean = false;        private var _maxZ:Number = -Infinity;        private var _minZElement:IMeshElement = null;        private var _minZDirty:Boolean = false;        private var _minZ:Number = Infinity;        private var _needNotifyRadiusChange:Boolean = false;        private var _needNotifyDimensionsChange:Boolean = false;        private var _frame:int;        private var _animation:Animation;		private var _animationgroup:AnimationGroup;        private var _sequencedone:Event;        private var _cycle:Event;		private var _activeprefix:String;        private var _seg:DrawSegment;        private var _dsStore:Array = new Array();        private var _dsActive:Array = new Array();		        private function launchNotifies():void        {            if (_needNotifyRadiusChange)            {                _needNotifyRadiusChange = false;                notifyRadiusChange();            }            if (_needNotifyDimensionsChange)            {                _needNotifyDimensionsChange = false;                notifyDimensionsChange();            }        }        private function rememberElementRadius(element:IMeshElement):void        {            var r2:Number = element.radius2;            if (r2 > _boundingRadius*_boundingRadius)            {                _boundingRadius = Math.sqrt(r2);                _boundingRadiusElement = element;                _boundingRadiusDirty = false;                _needNotifyRadiusChange = true;            }            var mxX:Number = element.maxX;            if (mxX > _maxX)            {                _maxX = mxX;                _maxXElement = element;                _maxXDirty = false;                _needNotifyDimensionsChange = true;            }            var mnX:Number = element.minX;            if (mnX < _minX)            {                _minX = mnX;                _minXElement = element;                _minXDirty = false;                _needNotifyDimensionsChange = true;            }            var mxY:Number = element.maxY;            if (mxY > _maxY)            {                _maxY = mxY;                _maxYElement = element;                _maxYDirty = false;                _needNotifyDimensionsChange = true;            }            var mnY:Number = element.minY;            if (mnY < _minY)            {                _minY = mnY;                _minYElement = element;                _minYDirty = false;                _needNotifyDimensionsChange = true;            }            var mxZ:Number = element.maxZ;            if (mxZ > _maxZ)            {                _maxZ = mxZ;                _maxZElement = element;                _maxZDirty = false;                _needNotifyDimensionsChange = true;            }            var mnZ:Number = element.minZ;            if (mnZ < _minZ)            {                _minZ = mnZ;                _minZElement = element;                _minZDirty = false;                _needNotifyDimensionsChange = true;            }        }        private function forgetElementRadius(element:IMeshElement):void        {            if (element == _boundingRadiusElement)            {                _boundingRadiusElement = null;                _boundingRadiusDirty = true;                _needNotifyRadiusChange = true;            }            if (element == _maxXElement)            {                _maxXElement = null;                _maxXDirty = true;                _needNotifyDimensionsChange = true;            }            if (element == _minXElement)            {                _minXElement = null;                _minXDirty = true;                _needNotifyDimensionsChange = true;            }            if (element == _maxYElement)            {                _maxYElement = null;                _maxYDirty = true;                _needNotifyDimensionsChange = true;            }            if (element == _minYElement)            {                _minYElement = null;                _minYDirty = true;                _needNotifyDimensionsChange = true;            }            if (element == _maxZElement)            {                _maxZElement = null;                _maxZDirty = true;                _needNotifyDimensionsChange = true;            }            if (element == _minZElement)            {                _minZElement = null;                _minZDirty = true;                _needNotifyDimensionsChange = true;            }        }        private function onElementVertexChange(event:MeshElementEvent):void        {            var element:IMeshElement = event.element;            forgetElementRadius(element);            rememberElementRadius(element);            _verticesDirty = true;            launchNotifies();        }        private function onElementVertexValueChange(event:MeshElementEvent):void        {            var element:IMeshElement = event.element;            forgetElementRadius(element);            rememberElementRadius(element);            launchNotifies();        }				/*        private function clear():void        {            throw new Error("Not implemented");        }        */                private function updatePlaySequence(e:Event):void		{			 			if(_animationgroup.playlist.length == 0 ){				_animation.removeEventListener(AnimationEvent.SQUENCE_UPDATE, updatePlaySequence);				_animation.sequenceEvent = false;								if (hasSequenceEvent) {					if (_sequencedone == null)						_sequencedone = new Event(AnimationEvent.SQUENCE_DONE);										dispatchEvent(_sequencedone);				}			} else{							if(_animationgroup.playlist.length == 1 )  loop = _animationgroup.loopLast;					play(_animationgroup.playlist.shift());			}			 		}            	/**    	 * Scales the contents of the mesh using 3 axis values.    	 *     	 * @param	scaleX	The scaling value along the x-axis    	 * @param	scaleY	The scaling value along the y-axis    	 * @param	scaleZ	The scaling value along the z-axis    	 */        protected function scaleXYZ(scaleX:Number, scaleY:Number, scaleZ:Number):void        {            for each (var vertex:Vertex in vertices)            {                vertex.x *= scaleX;                vertex.y *= scaleY;                vertex.z *= scaleZ;            }        }				/**		 * Adds an element to the mesh object.		 * 		 * @param	element		The element to be added to the mesh.		 */        protected function addElement(element:IMeshElement):void        {            _verticesDirty = true;                                          element.addOnVertexChange(onElementVertexChange);            element.addOnVertexValueChange(onElementVertexValueChange);                                                            rememberElementRadius(element);            launchNotifies();        }				/**		 * Removes an element to the mesh object.		 * 		 * @param	element		The element to be removed from the mesh.		 */        protected function removeElement(element:IMeshElement):void        {            forgetElementRadius(element);            element.removeOnVertexValueChange(onElementVertexValueChange);            element.removeOnVertexChange(onElementVertexChange);            _verticesDirty = true;            launchNotifies();        }                /**        * A dictionary containing all frames of the mesh        */        public var frames:Dictionary;                /**        * A dictionary containing all frame names of the mesh        */        public var framenames:Dictionary;				/**		 * Elements use their furthest point from the camera when z-sorting		 */        public var pushback:Boolean;				/**		 * Elements use their nearest point to the camera when z-sorting		 */        public var pushfront:Boolean;				/**		 * String defining the source of the mesh.		 * 		 * If the mesh has been created internally, the string is used to display the package name of the creating object.		 * Used to display information in the stats panel		 * 		 * @see away3d.core.stats.Stats		 */       	public var url:String;				/**		 * String defining the type of class used to generate the mesh.		 * Used to display information in the stats panel		 * 		 * @see away3d.core.stats.Stats		 */       	public var type:String;       	        /**        * Returns an array of the elements contained in the mesh object        *         * @throws	Error	Not implemented        */        public function get elements():Array        {            throw new Error("Not implemented");        }                /**        * Returns an array of the vertices contained in the mesh object        */        public function get vertices():Array        {            if (_verticesDirty)            {                _vertices = [];                var processed:Dictionary = new Dictionary();                for each (var element:IMeshElement in elements)                    for each (var vertex:Vertex in element.vertices)                        if (!processed[vertex])                        {                            _vertices.push(vertex);                            processed[vertex] = true;                        }                _verticesDirty = false;            }            return _vertices;        }        		/**		 * @inheritDoc		 */        public override function get boundingRadius():Number        {            if (_boundingRadiusDirty)            {                _boundingRadiusElement = null;                var mr:Number = 0;                for each (var element:IMeshElement in elements)                {                    var r2:Number = element.radius2;                    if (r2 > mr)                    {                        mr = r2;                        _boundingRadiusElement = element;                    }                }                _boundingRadius = Math.sqrt(mr);                _boundingRadiusDirty = false;            }            return _boundingRadius;        }        		/**		 * @inheritDoc		 */        public override function get maxX():Number        {            if (_maxXDirty)            {                _maxXElement = null;                var extrval:Number = -Infinity;                for each (var element:IMeshElement in elements)                {                    var val:Number = element.maxX;                    if (val > extrval)                    {                        extrval = val;                        _maxXElement = element;                    }                }                _maxX = extrval;                _maxXDirty = false;            }            return _maxX;        }        		/**		 * @inheritDoc		 */        public override function get minX():Number        {            if (_minXDirty)            {                _minXElement = null;                var extrval:Number = Infinity;                for each (var element:IMeshElement in elements)                {                    var val:Number = element.minX;                    if (val < extrval)                    {                        extrval = val;                        _minXElement = element;                    }                }                _minX = extrval;                _minXDirty = false;            }            return _minX;        }        		/**		 * @inheritDoc		 */        public override function get maxY():Number        {            if (_maxYDirty)            {                var extrval:Number = -Infinity;                _maxYElement = null;                for each (var element:IMeshElement in elements)                {                    var val:Number = element.maxY;                    if (val > extrval)                    {                        extrval = val;                        _maxYElement = element;                    }                }                _maxY = extrval;                _maxYDirty = false;            }            return _maxY;        }        		/**		 * @inheritDoc		 */        public override function get minY():Number        {            if (_minYDirty)            {                var extrval:Number = Infinity;                _minYElement = null;                for each (var element:IMeshElement in elements)                {                    var val:Number = element.minY;                    if (val < extrval)                    {                        extrval = val;                        _minYElement = element;                    }                }                _minY = extrval;                _minYDirty = false;            }            return _minY;        }        		/**		 * @inheritDoc		 */        public override function get maxZ():Number        {            if (_maxZDirty)            {                var extrval:Number = -Infinity;                _maxZElement = null;                for each (var element:IMeshElement in elements)                {                    var val:Number = element.maxZ;                    if (val > extrval)                    {                        extrval = val;                        _maxZElement = element;                    }                }                _maxZ = extrval;                _maxZDirty = false;            }            return _maxZ;        }        		/**		 * @inheritDoc		 */        public override function get minZ():Number        {            if (_minZDirty)            {                var extrval:Number = Infinity;                _minZElement = null;                for each (var element:IMeshElement in elements)                {                    var val:Number = element.minZ;                    if (val < extrval)                    {                        extrval = val;                        _minZElement = element;                    }                }                _minZ = extrval;                _minZDirty = false;            }            return _minZ;        }				/**		 * Indicates the current frame of animation		 */        public function get frame():int        {            return _animation.frame;        }                public function set frame(value:int):void        {            if (_animation.frame == value)                return;			_frame = value;            _animation.frame = value;            frames[value].adjust(1);        }        		/**		 * Indicates whether the animation has a cycle event listener		 */		public function get hasCycleEvent():Boolean        {			return _animation.hasEventListener(AnimationEvent.CYCLE);        }        		/**		 * Indicates whether the animation has a sequencedone event listener		 */		public function get hasSequenceEvent():Boolean        {			return hasEventListener(AnimationEvent.SQUENCE_DONE);        }        		/**		 * Determines the frames per second at which the animation will run.		 */		public function set fps(value:int):void		{			_animation.fps = (value>=1)? value : 1;		}				/**		 * Determines whether the animation will loop.		 */		public function set loop(loop:Boolean):void		{			_animation.loop = loop;		}                /**        * Determines whether the animation will smooth motion (interpolate) between frames.        */		public function set smooth(smooth:Boolean):void		{			_animation.smooth = smooth;		}				/**		 * Indicates whether the animation is currently running.		 */		public function get isRunning():Boolean		{			return _animation.isRunning;		}				/**		 * Creates a new <code>BaseMesh</code> object.		 *		 * @param	init			[optional]	An initialisation object for specifying default instance properties		 */        public function BaseMesh(init:Object = null)        {            super(init);                        pushback = ini.getBoolean("pushback", false);            pushfront = ini.getBoolean("pushfront", false);        }            	/**    	 * Scales the contents of the mesh.    	 *     	 * @param	scale	The scaling value    	 */        public override function scale(scale:Number):void        {            scaleXYZ(scale, scale, scale);        }		    	/**    	 * Scales the contents of the mesh along the x-axis.    	 *     	 * @param	scaleX	The scaling value    	 */        public function scaleX(scaleX:Number):void        {            if (scaleX != 1)                scaleXYZ(scaleX, 1, 1);        }		    	/**    	 * Scales the contents of the mesh along the y-axis.    	 *     	 * @param	scaleX	The scaling value    	 */        public function scaleY(scaleY:Number):void        {            if (scaleY != 1)                scaleXYZ(1, scaleY, 1);        }		    	/**    	 * Scales the contents of the mesh along the z-axis.    	 *     	 * @param	scaleX	The scaling value    	 */        public function scaleZ(scaleZ:Number):void        {            if (scaleZ != 1)                scaleXYZ(1, 1, scaleZ);        }        		/**		 * @inheritDoc		 *     	 * @see	away3d.core.traverse.PrimitiveTraverser    	 * @see	away3d.core.draw.DrawPrimitive		 */		override public function primitives(consumer:IPrimitiveConsumer, session:AbstractRenderSession):void        {        	super.primitives(consumer, session);        	_dsStore = _dsStore.concat(_dsActive);        	_dsActive = new Array();        }				/**		 * Starts playing the animation at the specified frame.		 * 		 * @param	value		A number representing the frame number.		 */		public function gotoAndPlay(value:int):void		{			_frame = _animation.frame = value;						if(!_animation.isRunning)				_animation.start();		}				/**		 * Brings the animation to the specifed frame and stops it there.		 * 		 * @param	value		A number representing the frame number.		 */		public function gotoAndStop(value:int):void		{			_frame = _animation.frame = value;						if(_animation.isRunning)				_animation.stop();		}				/**		 * Passes an array of animationsequence objects to be added to the animation.		 * 		 * @param	playlist				An array of animationsequence objects.		 * @param	loopLast	[optional]	Determines whether the last sequence will loop. Defaults to false.		 */		public function setPlaySequences(playlist:Array, loopLast:Boolean = false):void		{			if(playlist.length == 0)				return;						if(!_animation)				_animation = new Animation(this); 						_animationgroup = new AnimationGroup();			_animationgroup.loopLast = loopLast;			_animationgroup.playlist = [];						for(var i:int = 0;i<playlist.length;i++ )				_animationgroup.playlist[i] = new AnimationSequence(playlist[i].prefix, playlist[i].smooth, true, playlist[i].fps);			 			if(!_animation.hasEventListener(AnimationEvent.SQUENCE_UPDATE))				_animation.addEventListener(AnimationEvent.SQUENCE_UPDATE, updatePlaySequence);						_animation.sequenceEvent = true;			loop = true;			play(_animationgroup.playlist.shift());		}				/**		 * Default method for adding a squencedone event listener		 * 		 * @param	listener		The listener function		 */		public function addOnSequenceDone(listener:Function):void        {            addEventListener(AnimationEvent.SQUENCE_DONE, listener, false, 0, false);        }				/**		 * Default method for removing a squencedone event listener		 * 		 * @param	listener		The listener function		 */		public function removeOnSequenceDone(listener:Function):void        {            removeEventListener(AnimationEvent.SQUENCE_DONE, listener, false);        }				/**		 * Default method for adding a cycle event listener		 * 		 * @param	listener		The listener function		 */		public function addOnCycle(listener:Function):void        {			_animation.cycleEvent = true;			_cycle = new Event(AnimationEvent.CYCLE);			_animation.addEventListener(AnimationEvent.CYCLE, listener, false, 0, false);        }				/**		 * Default method for removing a cycle event listener		 * 		 * @param	listener		The listener function		 */		public function removeOnCycle(listener:Function):void        {			_animation.cycleEvent = false;            _animation.removeEventListener(AnimationEvent.CYCLE, listener, false);        }				/**		 * Called by the <code>TickTraverser</code>.		 * 		 * updates the animation object		 * 		 * @param	time		The absolute time at the start of the render cycle		 * 		 * @see away3d.core.traverse.TickTraverser		 * @see away3d.core.basr.Animation#update()		 */        public override function tick(time:int):void        {            if ((_animation != null) && (frames != null))                _animation.update(this);        }				/**		 * Scales the vertex positions contained within all animation frames		 * 		 * @param	scale	The scaling value		 */		public function scaleAnimation(scale:Number):void		{			var tmpnames:Array = new Array();			var i:int = 0;			var y:int = 0;			for (var framename:String in framenames){				tmpnames.push(framename);			}							var fr:Frame;			for (i = 0;i<tmpnames.length;i++){				fr = frames[framenames[tmpnames[i]]];				for(y = 0; y<fr.vertexpositions.length ;y++){					fr.vertexpositions[y].x *= scale;					fr.vertexpositions[y].y *= scale;					fr.vertexpositions[y].z *= scale;				}			}						}				/**		 * Plays a sequence of frames		 * 		 * @param	sequence	The animationsequence to play		 */        public function play(sequence:AnimationSequence):void        {			if(!_animation){            	_animation = new Animation(this); 			} else{				_animation.sequence = new Array();			}			            _animation.fps = sequence.fps;            _animation.smooth = sequence.smooth;            _animation.loop = sequence.loop;			            if (sequence.prefix != null){				var bvalidprefix:Boolean;                for (var framename:String in framenames){                    if (framename.indexOf(sequence.prefix) == 0){						bvalidprefix = true;						_activeprefix = (_activeprefix != sequence.prefix)? sequence.prefix : _activeprefix ;                        _animation.sequence.push(new AnimationFrame(framenames[framename], "" + parseInt(framename.substring(sequence.prefix.length))));					}				}								if(bvalidprefix){					_animation.sequence.sortOn("sort", Array.NUMERIC );            					frames[_frame].adjust(1);					_animation.start();					//trace(">>>>>>>> [  start "+activeprefix+"  ]");				} else{					trace("--------- \n--> unable to play animation: unvalid prefix ["+sequence.prefix+"]\n--------- ");				}			}        }    }}                                